   <Modal
        visible={true}
        onRequestClose={closeModal}
        animationType="slide"
        transparent={true}
      >
        <View style={styles.modalContainer}>
          <LinearGradient
            colors={[
              "rgba(0,0,0,0)",
              "rgba(0,0,0,0.7)",
              "rgba(0,0,0,0.9)",
              "rgba(0,0,0,0.9)",
              "rgba(0,0,0,0.9)",
              "rgba(0,0,0,0.7)",
              "rgba(0,0,0,0)",
            ]}
            style={{
              position: "absolute",
              top: 0,
              right: 0,
              left: 0,
              bottom: 0,
            }}
          />
          <TouchableOpacity
            style={{
              position: "absolute",
              top: 0,
              right: 0,
              left: 0,
              bottom: 0,
            }}
            onPress={closeModal}
          />
          <View style={styles.modalContent}>
            {/* İleride başka seçenekler de ekleyebilirsin */}
            <TouchableOpacity style={styles.input} onPress={showDatePicker}>
              <Text style={styles.inputText}>
                Seçilen Tarih:{" "}
                {selectedDate ? formatDate(selectedDate) : "Tarih seçiniz"}
              </Text>
            </TouchableOpacity>
            <DateTimePickerModal
              isVisible={isDatePickerVisible}
              mode="date"
              onConfirm={handleConfirm}
              onCancel={hideDatePicker}
            />
            <TouchableOpacity
              style={[
                styles.input,
                { backgroundColor: theme.colors.green, marginTop: 10 },
              ]}
              onPress={markEpisodeAsWatched}
              disabled={!selectedDate}
            >
              <Text style={[styles.inputText, { color: "#fff" }]}>Kaydet</Text>
            </TouchableOpacity>
            {/* Buraya başka butonlar veya seçenekler ekleyebilirsin */}
          </View>
        </View>
      </Modal>



 modalContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  modalContent: {
    backgroundColor: "#222",
    borderRadius: 16,
    padding: 24,
    minWidth: 250,
    alignItems: "center",
  },
  input: {
    backgroundColor: "#333",
    borderRadius: 8,
    padding: 12,
    marginVertical: 8,
    minWidth: 180,
    alignItems: "center",
  },
  inputText: {
    color: "#fff",
    fontSize: 16,
  },



       // Modal ve tarih seçici state'leri
  const [modalVisible, setModalVisible] = useState(false);
  const [isDatePickerVisible, setDatePickerVisibility] = useState(false);
  const [selectedDate, setSelectedDate] = useState(null);

  // Modal aç
  const openModal = () => setModalVisible(true);
  const closeModal = () => {
    setModalVisible(false);
    setSelectedDate(null);
  };

  // Tarih seçici aç/kapat
  const showDatePicker = () => setDatePickerVisibility(true);
  const hideDatePicker = () => setDatePickerVisibility(false);

  // Tarih seçilince
  const handleConfirm = (date) => {
    setSelectedDate(date);
    hideDatePicker();
  };





  const addShowToFirestore = async (selectedDate = null) => {
    console.log(1);
    if (!user || !details || !details.seasons) return;

    try {
      setIsLoading(true);
      closeModal();

      const userRef = doc(db, "Lists", user.uid);
      const docSnap = await getDoc(userRef);

      let data = docSnap.exists() ? docSnap.data() : { watchedTv: [] };
      let watchedTv = data.watchedTv || [];
      let tvShowIndex = watchedTv.findIndex((show) => show.id === details.id);

      if (!selectedDate) return; // Tarih seçilmeden ekleme yapılmasın

      const episodeDate = formatDateSave(selectedDate);
      if (tvShowIndex == -1) {
        Toast.show({
          type: "success",
          text1: "Dizi Bölümleri izlendi olarak işaretleniyor",
        });
      }
      const handleRemoveWatchedTv = async () => {
        if (tvShowIndex !== -1) {
          watchedTv.splice(tvShowIndex, 1);
          await updateDoc(userRef, { watchedTv });
          checkIfWatched();
        }
      };
      if (tvShowIndex !== -1) {
        Toast.show({
          type: "warning",
          text1: "Dizi izleme listesinden silindi",
        });
        await handleRemoveWatchedTv();
        return;
      }

      // Her sezon için API'den bölümleri çek ve ekle
      for (const seasonObj of details.seasons) {
        // Sezon numarası 0 olanlar (specials) genelde atlanır, istersen kontrol ekleyebilirsin
        if (!seasonObj.season_number || seasonObj.episode_count === 0) continue;

        const response = await axios.get(
          `https://api.themoviedb.org/3/tv/${details.id}/season/${seasonObj.season_number}`,
          {
            params: { language: language === "tr" ? "tr-TR" : "en-US" },
            headers: {
              accept: "application/json",
              Authorization: API_KEY,
            },
          }
        );
        for (const element of response.data.episodes) {
          await markEpisodeAsWatched({
            showId: details.id,
            showReleaseDate: episodeDate,
            seasonNumber: seasonObj.season_number,
            showName: details.name,
            showEpisodeCount: details.number_of_episodes,
            showSeasonCount: details.number_of_seasons,
            showPosterPath: details.poster_path,
            seasonPosterPath: seasonObj.poster_path,
            seasonEpisodes: seasonObj.episode_count,
            episodeNumber: element.episode_number,
            episodePosterPath: element.still_path,
            episodeName: element.name,
            episodeRatings: element.vote_average?.toFixed(1) ?? 0,
            episodeMinutes: element.runtime,
            genres: details.genres,
          });
        }
      }

      checkIfWatched();
    } catch (error) {
      console.error("Dizi eklenirken hata oluştu:", error);
    } finally {
      setIsLoading(false);
    }
  };
  const markEpisodeAsWatched = async ({
    showId,
    showName,
    showEpisodeCount,
    showSeasonCount,
    showPosterPath,
    seasonNumber,
    seasonPosterPath,
    seasonEpisodes,
    episodeNumber,
    episodePosterPath,
    episodeName,
    episodeRatings,
    episodeMinutes,
    showReleaseDate,
    genres,
  }) => {
    try {
      setIsLoading(true);
      const userRef = doc(db, "Lists", user.uid);
      const docSnap = await getDoc(userRef);

      let data = docSnap.exists() ? docSnap.data() : { watchedTv: [] };
      let watchedTv = data.watchedTv || [];

      let tvShowIndex = watchedTv.findIndex((show) => show.id === showId);

      // EKLEME İŞLEMİ (tarih seçilmeden ekleme yapılmasın)
      if (!showReleaseDate) return;
      if (tvShowIndex === -1) {
        watchedTv.push({
          id: showId,
          name: showName,
          showEpisodeCount: showEpisodeCount,
          showSeasonCount: showSeasonCount,
          imagePath: showPosterPath,
          type: "tv",
          addedShowDate: showReleaseDate,
          genres: genres ? genres.map((g) => g.name) : [], // <-- EKLENDİ
          seasons: [
            {
              seasonNumber: seasonNumber,
              seasonPosterPath: seasonPosterPath || null,
              seasonEpisodes: seasonEpisodes,
              addedSeasonDate: showReleaseDate,
              episodes: [
                {
                  episodeNumber: episodeNumber,
                  episodePosterPath: episodePosterPath || null,
                  episodeName: episodeName || "Unknown",
                  episodeRatings: episodeRatings || 0,
                  episodeMinutes: episodeMinutes || 0,
                  episodeWatchTime: showReleaseDate,
                },
              ],
            },
          ],
        });
      } else {
        let show = watchedTv[tvShowIndex];
        if (!show.addedShowDate) show.addedShowDate = showReleaseDate;

        let seasons = show.seasons || [];
        let seasonIndex = seasons.findIndex(
          (season) => season.seasonNumber === seasonNumber
        );

        if (seasonIndex === -1) {
          seasons.push({
            seasonNumber: seasonNumber,
            seasonPosterPath: seasonPosterPath || null,
            seasonEpisodes: seasonEpisodes,
            addedSeasonDate: showReleaseDate,
            episodes: [
              {
                episodeNumber: episodeNumber,
                episodePosterPath: episodePosterPath || null,
                episodeName: episodeName || "Unknown",
                episodeRatings: episodeRatings || 0,
                episodeMinutes: episodeMinutes || 0,
                episodeWatchTime: showReleaseDate,
              },
            ],
          });
          show.seasons = seasons;
        } else {
          let season = seasons[seasonIndex];
          if (!season.addedSeasonDate) season.addedSeasonDate = showReleaseDate;

          let episodes = season.episodes || [];
          let episodeIndex = episodes.findIndex(
            (ep) => ep.episodeNumber === episodeNumber
          );

          if (episodeIndex === -1) {
            episodes.push({
              episodeNumber: episodeNumber,
              episodePosterPath: episodePosterPath || null,
              episodeName: episodeName || "Unknown",
              episodeRatings: episodeRatings || 0,
              episodeMinutes: episodeMinutes || 0,
              episodeWatchTime: showReleaseDate,
            });
            season.episodes = episodes;
          }
        }
      }

      await updateDoc(userRef, { watchedTv });
      checkIfWatched();
    } catch (error) {
      console.error("Hata:", error);
    } finally {
      setIsLoading(false);
    }
  };




  const [listVisible, setListVisible] = useState([]);

  // Firestore'dan çek
  useEffect(() => {
    const fetchListVisible = async () => {
      if (!user) return;
      const userRef = doc(db, "Users", user.uid);
      const userSnap = await getDoc(userRef);
      if (userSnap.exists()) {
        setListVisible(userSnap.data().listVisible || []);
      }
    };

    fetchListVisible();
  }, [user]);

  const addToListVisible = async (listName) => {
    if (!user) return;
    const userRef = doc(db, "Users", user.uid);

    // Array'i kopyala
    const updatedList = [...listVisible];
    let found = false;

    // Var olan objeyi bul ve tersine çevir
    for (let i = 0; i < updatedList.length; i++) {
      if (listName in updatedList[i]) {
        updatedList[i][listName] = !updatedList[i][listName];
        found = true;
        break;
      }
    }

    // Bulunamadıysa yeni obje ekle
    if (!found) {
      updatedList.push({ [listName]: true });
    }

    // Firestore'a yaz ve state'i güncelle
    await setDoc(userRef, { listVisible: updatedList }, { merge: true });
    setListVisible(updatedList);
  };